//\n//  CustomizablePitchAccentGraphView.swift\n//  Shiori Reader\n//\n//  Created by Claude on 6/14/25.\n//\n\nimport SwiftUI\n\n/// A customizable pitch accent graph that allows setting colors for Anki export\nstruct CustomizablePitchAccentGraphView: View {\n    let word: String\n    let reading: String\n    let pitchValue: Int\n    let graphColor: Color\n    let textColor: Color\n    \n    // Drawing constants - smaller for Anki export\n    private let stepWidth: CGFloat = 18\n    private let marginLR: CGFloat = 8\n    private let dotRadius: CGFloat = 2.5\n    private let highY: CGFloat = 6\n    private let lowY: CGFloat = 18\n    private let lineWidth: CGFloat = 1.5\n    \n    var body: some View {\n        pitchGraphView\n    }\n    \n    private var pitchGraphView: some View {\n        let textToAnalyze = reading.isEmpty ? word : reading\n        let mora = JapanesePitchAccentUtils.extractMora(from: textToAnalyze)\n        let pattern = JapanesePitchAccentUtils.generatePitchPattern(moraCount: mora.count, pitchValue: pitchValue)\n        \n        // Ensure width includes the last circle properly\n        let graphWidth = max(CGFloat(max(mora.count, pattern.count) - 1) * stepWidth + marginLR * 2, 60)\n        \n        return ZStack(alignment: .topLeading) {\n            // Background canvas for lines and dots only (no text)\n            Canvas { context, size in\n                // Draw connecting lines and dots\n                var previousPoint: CGPoint?\n                \n                for (index, accent) in pattern.enumerated() {\n                    let xCenter = marginLR + CGFloat(index) * stepWidth\n                    let yCenter: CGFloat = (accent == \"H\") ? highY : lowY\n                    let currentPoint = CGPoint(x: xCenter, y: yCenter)\n                    \n                    // Draw connecting line from previous point\n                    if let prevPoint = previousPoint {\n                        // Calculate line endpoints to stop at circle borders\n                        let dx = currentPoint.x - prevPoint.x\n                        let dy = currentPoint.y - prevPoint.y\n                        let distance = sqrt(dx * dx + dy * dy)\n                        \n                        if distance > 0 {\n                            // Normalize direction vector\n                            let unitX = dx / distance\n                            let unitY = dy / distance\n                            \n                            // Calculate start and end points at circle borders\n                            let startPoint = CGPoint(\n                                x: prevPoint.x + unitX * dotRadius,\n                                y: prevPoint.y + unitY * dotRadius\n                            )\n                            let endPoint = CGPoint(\n                                x: currentPoint.x - unitX * dotRadius,\n                                y: currentPoint.y - unitY * dotRadius\n                            )\n                            \n                            var path = Path()\n                            path.move(to: startPoint)\n                            path.addLine(to: endPoint)\n                            \n                            context.stroke(path, with: .color(graphColor), lineWidth: lineWidth)\n                        }\n                    }\n                    \n                    // Draw dot\n                    let dotRect = CGRect(\n                        x: currentPoint.x - dotRadius,\n                        y: currentPoint.y - dotRadius,\n                        width: dotRadius * 2,\n                        height: dotRadius * 2\n                    )\n                    \n                    // Use hollow circle for points beyond mora count\n                    if index >= mora.count {\n                        context.stroke(\n                            Circle().path(in: dotRect),\n                            with: .color(graphColor),\n                            lineWidth: 1\n                        )\n                    } else {\n                        context.fill(\n                            Circle().path(in: dotRect),\n                            with: .color(graphColor)\n                        )\n                    }\n                    \n                    previousPoint = currentPoint\n                }\n            }\n            \n            // Overlay Text views for reliable Japanese character rendering\n            ForEach(Array(mora.enumerated()), id: \\.offset) { index, moraChar in\n                let xCenter = marginLR + CGFloat(index) * stepWidth\n                \n                Text(moraChar)\n                    .font(.caption2)\n                    .foregroundColor(textColor)\n                    .position(x: xCenter, y: lowY + 12)\n            }\n        }\n        .frame(width: graphWidth, height: 35)\n    }\n}\n\n#Preview {\n    VStack(spacing: 10) {\n        CustomizablePitchAccentGraphView(\n            word: \"はし\", \n            reading: \"はし\", \n            pitchValue: 0,\n            graphColor: .black,\n            textColor: .black\n        )\n        \n        CustomizablePitchAccentGraphView(\n            word: \"はし\", \n            reading: \"はし\", \n            pitchValue: 1,\n            graphColor: .blue,\n            textColor: .blue\n        )\n        \n        CustomizablePitchAccentGraphView(\n            word: \"がっこう\", \n            reading: \"がっこう\", \n            pitchValue: 0,\n            graphColor: .white,\n            textColor: .gray\n        )\n        .background(Color.black) // To show white graph\n    }\n    .padding()\n}\n